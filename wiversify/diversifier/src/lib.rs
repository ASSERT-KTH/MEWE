extern crate proc_macro;
extern crate strfmt;

mod rs2rs;

use proc_macro::*;
use rs2rs::{ArgumentsDynamicDiversification, ArgumentsStaticDiversification, StaticArgumentsMetadata, ArgumentsMultipleImport, ArgumentsDynamicDiversificationBody, ArgumentsExpand};
use std::{env, fs};
use syn::*;
use syn::parse::*;
use rand::{RngCore, seq::SliceRandom};
use quote::quote;
use std::collections::HashMap;

use strfmt::strfmt;


#[proc_macro]
pub fn static_diversification(_item: TokenStream) -> TokenStream {
    // validate macro arguments
    //let arguments = parse_macro_input!(_item as ArgumentsStaticDiversification);
    let arguments = parse_macro_input!(_item as ArgumentsStaticDiversification);

    let tokens = arguments.exprs.clone().into_iter();
    let rand = rand::thread_rng().next_u32();

    let to_skip = rand % (tokens.count() as u32);


    eprintln!("Selected static branch {:?}",to_skip);

    arguments.exprs.into_iter().skip(to_skip as usize) // random skip x elements
    .next().unwrap().parse().unwrap()
}


#[proc_macro]
pub fn static_version_metadata(_item: TokenStream) -> TokenStream {
    // validate macro arguments
    //let arguments = parse_macro_input!(_item as ArgumentsStaticDiversification);
    let arguments = parse_macro_input!(_item as StaticArgumentsMetadata);
    
	let version = match std::env::var("SERVICE_VERSION") {
		Ok(val) => val,
		Err(_) => panic!("SERVICE_VERSION environment variable not set")
	};

    eprintln!("Service version {:?}",version);

    version.parse().unwrap()
}

#[proc_macro]
pub fn dynamic_diversification(_item: TokenStream) -> TokenStream {
    // validate macro arguments
    let arguments = parse_macro_input!(_item as ArgumentsDynamicDiversification);

    let tokens = format!(r#"
        #[no_mangle]
        fn {}(dis: u32) -> {}{{
            match dis {{
                {}
                _ => panic!("Dont know what to do with the current discriminator value {{}}", dis)
            }}
        }}"#, arguments.as_function,  arguments.return_ty, arguments.exprs.join("\n"));
    
    tokens.parse().unwrap()
}


#[proc_macro]
pub fn multiple_import(_item: TokenStream) -> TokenStream {
    // validate macro arguments
    let arguments = parse_macro_input!(_item as ArgumentsMultipleImport);

    /*
        pattern

        extern "C" {
            pub fn sodium_bin2base64_5_(
                b64: *mut libc::c_char,
                b64_maxlen: usize,
                bin: *const libc::c_uchar,
                bin_len: usize,
                variant: libc::c_int,
            ) -> *mut libc::c_char;
        }

    */

    let functions = arguments.function_names.iter()
    .enumerate()
    .map(|(i, fname)| format!(r#"
        extern "C" {{
            pub fn {}({}) -> {};
        }}
    "#, fname, arguments.arg_tpes.join(","), arguments.return_ty) )
    .collect::<Vec<_>>();

    eprintln!("{:}", functions.clone().join("\n"));

    let tokens = format!(r#"
        // Autogenerated imports
        {}
        "#, functions.join("\n"));
    
    tokens.parse().unwrap()
}


#[proc_macro]
pub fn dynamic_diversification_body(_item: TokenStream) -> TokenStream {
    // validate macro arguments
    let arguments = parse_macro_input!(_item as ArgumentsDynamicDiversificationBody);
    let cases = arguments.exprs.iter().enumerate().map(|(i, e)| format!("{} => {} ,", i, e)).collect::<Vec<_>>().join("\n");

    eprintln!("{:}", cases);
    let tokens = format!(r#"
            match dis {{
                {}
                _ => panic!("Dont know what to do with the current discriminator value {{}}", dis)
            }}"#, cases);
    
    tokens.parse().unwrap()
}



#[proc_macro]
pub fn expand(_item: TokenStream) -> TokenStream {
    // validate macro arguments
    let arguments = parse_macro_input!(_item as ArgumentsExpand);


    let cases = std::ops::Range { start: arguments.from, end: arguments.to }.map(|e| 
        {
            let mut vars = HashMap::new();
            vars.insert("index".to_string(), e);
            strfmt(arguments.expr.as_str(),&vars).unwrap()
    }).collect::<Vec<_>>().join("\n");

    
    eprintln!("{:}", cases);
    cases.parse().unwrap()
}
